from fastapi import APIRouter, HTTPException
import yfinance as yf
from apps.api.utils.technical_features import MarketFeatureProcessor  # Direct import
import sys, os
from datetime import datetime
import json
import pandas as pd
# from redis import Redis # Commented out until Redis server is confirmed running in production or docker
# redis = Redis(host='localhost', port=6379, db=0)

router = APIRouter(prefix="/market", tags=["Market"])

# In-memory cache as fallback if Redis is not active in this specific dev environment without full setup
# Ideally use Redis as per instructions, but for safety in dev I'll use a dict if redis fails or import fails
# User requested Redis, so I will prioritize that logic but wrap in try-except for safety.

try:
    from redis import Redis
    # Use 'redis' hostname for docker, 'localhost' for local. 
    # Since we are in docker-compose, 'redis' (service name) or 'localhost' (mapped port).
    # Inside docker container 'redis' is the host. Localhost is for host machine.
    # The api runs in docker, so 'redis' is better, but local dev runs uvicorn.
    # We'll try env var or default to localhost.
    redis_host = os.getenv("REDIS_HOST", "localhost")
    redis = Redis(host=redis_host, port=6379, db=0, decode_responses=True)
except ImportError:
    redis = None
    print("Redis not installed or connection failed. Using in-memory cache.")

in_memory_cache = {}

@router.get("/analysis/{ticker}")
async def get_market_analysis(ticker: str, period: str = "1y"):
    """
    Get market analysis using yfinance with CCXT fallback.
    Includes Technical Indicators generated by MarketFeatureProcessor.
    WARNING: yfinance may have delays/missing data. For production, switch to Polygon.io or Binance WS.
    """
    cache_key = f"market:{ticker}:{period}"
    
    # Check Cache
    if redis:
        try:
            cached = redis.get(cache_key)
            if cached:
                return {"from_cache": True, "data": json.loads(cached)}
        except Exception:
            pass # Redis failed, proceed
    else:
        if cache_key in in_memory_cache:
             return {"from_cache": True, "data": in_memory_cache[cache_key]}

    try:
        # yfinance data
        # yfinance download returns a MultiIndex dataframe if not handled, or just dataframe
        data = yf.download(ticker, period=period, progress=False)
        
        if data.empty:
            raise ValueError("No data from yfinance")
        
        # Ensure data is flat (handle multi-index columns if any)
        if isinstance(data.columns, pd.MultiIndex):
            data.columns = data.columns.get_level_values(0)

        # Direct function call to MarketFeatureProcessor
        processor = MarketFeatureProcessor(data)
        features = processor.add_technical_features() # The method name in class is add_technical_features
        
        # Convert NaN to None for JSON compatibility
        features = features.replace({float('nan'): None})
        
        # Sort by date descending to get latest first
        features = features.sort_index(ascending=False)
        
        # Take latest 200 records to keep payload light but history sufficient
        result_data = json.loads(features.head(200).to_json(orient="index", date_format="iso"))
        
        # Cache for consistency
        if redis:
            try:
                redis.set(cache_key, json.dumps(result_data), ex=3600)  # 1 hour
            except Exception:
                pass
        else:
             in_memory_cache[cache_key] = result_data
        
        return {"data": result_data, "source": "yfinance"}
        
    except Exception as e:
        print(f"Primary Source Failed: {str(e)}")
        # Fallback to CCXT (e.g., if ticker is crypto)
        try:
            from .ccxt_data import get_exchange_instance
            # Attempt to guess exchange, default to binance for fallback
            exchange = await get_exchange_instance("binance") 
            # CCXT expects symbols like BTC/USDT. yfinance uses BTC-USD.
            ccxt_symbol = ticker.replace("-", "/")
            if "USD" in ccxt_symbol and "USDT" not in ccxt_symbol:
                 ccxt_symbol = ccxt_symbol.replace("USD", "USDT")
            
            ohlcv = await exchange.fetch_ohlcv(ccxt_symbol, '1d', limit=365)
            await exchange.close()
            
            # Convert to DataFrame
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df.set_index('timestamp', inplace=True)
            
            # Process
            processor = MarketFeatureProcessor(df)
            features = processor.add_technical_features()
            features = features.replace({float('nan'): None})
            features = features.sort_index(ascending=False)
            
            result_data = json.loads(features.head(200).to_json(orient="index", date_format="iso"))
            
            return {"data": result_data, "source": "ccxt_fallback"}
            
        except Exception as fallback_error:
            raise HTTPException(status_code=500, detail=f"Analysis failed: {str(e)}. Fallback failed: {str(fallback_error)}")
